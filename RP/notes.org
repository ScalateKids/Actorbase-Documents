* Note Actorbase

** Idee random

*** Driver

- Parser JSON nella CLI, il driver potrebbe restituire solo JSON, possibile
  insensatezza che il driver restituisca stringhe
- Valutare raccoglimento comandi *molto* simili tra loro nel package control
- Utilizzare notazione OOP per la gestione del DB sul driver e.g:

#+begin_src scala
val client = new ActorbaseClient("localhost", 9999)
client.authenticate("foo", "bar") // boolean
val coll = client.createCollection("customers")
coll.insert("key", "value")
// oppure
coll.insert(new JSON("key", "value")) // da valutare
#+end_src

- Le collezioni dovranno essere indicizzate in qualche modo per distinguere le
  collezioni di ogni utente
- Utilizzare iteratori per restituire le ricerche e.g:
- Data package per classi sulla struttura del database (Collection, item, cursor..)
- Le classi del package Data avranno il metodo toJSON
- Valutare interfaccia con metodi toJSON e fromJSON

#+begin_src scala
val cursor = coll.find() // tutto il db
while(cursor.hasNext) {
  println(it.next)
}
#+end_src

*** Command Line Interface

- Valutare raccoglimento comandi *molto* simili tra loro nel package commands

*** TODO Cluster (System)

- Gestione tipi di dato
- Gestione persistenza, possibilit√† di nodi dedicati allo storage
- Popolamento iniziale:
  - Suddivisione mediante directory su FS: e.g. Coll/{0-63, 64-127}
  - Loader iniziale restituisce future al system e si crea la struttura degli actor
    partendo dagli SF.
  - Utilizzare i messaggi per proseguire il popolamento degli storekeeper ad albero.
  - Utilizzare un actor globale contenente tutti i ref degli sf, le connessioni in ingresso
    richiederanno al globale i reference dei propri sf.
