**** Driver usage: Generic example
#+begin_src scala
  import com.actorbase.driver._

  val auth = new ActorbaseDriver("localhost", 9999)
  val client = auth.authenticate("foo", "bar") // athentication method
  val coll = client.addCollection("people")
  // just a "key" -> "value" pair
  coll.insert("key" -> "value")
  // creating a simple Person class
  case class Person(name: String, age: Int)
  // insert Person type object..
  coll.insert("Seagal" -> Person("Steven", 64))
  //..and aother two
  coll.insert("Schwarzenegger" -> Person("Arnold", 68), "Stallone" -> Person("Sylvester", 70))
  // finally two totally different item
  coll.insert("Foo" -> 42, "bar" -> "baz")
  // printing all collection contents
  for ((k, v) <- coll)
    println(s"$k -> $v")
  // find some keys inside collection and do operations
  for ((k, v) <- coll.find("Arnold", "Foo")) {
    // operations...
  }

  // get all collections owned on the database
  val myCollections = client.getCollections
  // drop collections 'customers' and 'people'
  myCollections.drop("customers", "people")
#+end_src

**** Modify user password
#+begin_src scala
scala> client.changePassword("oldpw", "newpw")
res0: Boolean = true
#+end_src

**** Creating a new collection
#+begin_src scala
scala> client.addCollection("consumers")
res0: com.actorbase.driver.data.ActorbaseCollection
#+end_src
**** Listing collections
#+begin_src scala
scala> client.listCollections
res0: List[String] = List("customers")
#+end_src
**** Inserting into a collection
#+begin_src scala
scala> client.getCollection("people").insert("keyOne" -> "valueOne", "keyTwo" -> 42)
res0: com.actorbase.driver.data.ActorbaseCollection

scala> // variant
scala> client.getCollection("people").insert(ActorbaseObject("obj" -> "inserting with object"))
res1: com.actorbase.driver.data.ActorbaseCollection
#+end_src

**** Find into a collection
#+begin_src scala
scala> client.getCollection("people").find("keyOne" -> "valueOne", "keyTwo" -> 42)
res0: com.actorbase.driver.data.ActorbaseCollection

scala> client.getCollection("people").findOne("key" -> "value") // just a single value
res1: com.actorbase.driver.data.ActorbaseObject

#+end_src

**** Remove item
#+begin_src scala
scala> client.getCollection("people").remove("keyOne" -> "valueOne", "keyTwo" -> 42)
res0: com.actorbase.driver.data.ActorbaseCollection

scala> // variant
scala> client.getCollection("people").remove(ActorbaseObject("obj" -> "inserting with object"))
res1: com.actorbase.driver.data.ActorbaseCollection
#+end_src

**** Printing a collection
#+begin_src scala
scala> println(client.getCollection("people"))
{
  "owner": "foo",
  "collection": "people",
  "map": {
    "bar": "baz",
    "Foo": 42,
    "Seagal": {
        "type": "Person",
        "name": "Steven",
        "age": 64
    }
    "Schwarzenegger": {
        "type": "Person",
        "name": "Arnold",
        "age": 68
     }
    "Stallone": {
        "type": "Person",
        "name": "Sylvester",
        "age": 70
     }
  }
}

#+end_src

**** Printing some collections
#+begin_src scala
scala> client.getCollections.foreach(println)
#+end_src

**** Drop a collection
#+begin_src scala
scala> coll.drop
res0: Boolean = true
#+end_src

**** Drop some collections
#+begin_src scala
scala> client.dropCollections
res0: Boolean = true

scala> client.getCollections.drop
res0: Boolean = true
#+end_src

**** Count collections elements
#+begin_src scala
scala> println(client.getCollection("people").count)
res0: Int = 3
#+end_src

**** Import from file
#+begin_src scala
scala> client.importFromFile("foo/bar/baz.json")
res0: Boolean = true
#+end_src
**** Export to file
#+begin_src scala
scala> client.exportToFile("foo/bar/customers_people.json", "customers", "people")
res0: Boolean = true

scala> client.exportToFile("foo/bar/all_collections.json")
res1: Boolean = true
#+end_src
**** Contributor operations
#+begin_src scala
scala> val fooCollection = client.getCollection("foo")
scala> fooCollection.addContributor("aFriend") // add
res0: Boolean = true

scala> fooCollection.removeContributor("aFriend") // remove
res1: Boolean = true
#+end_src

**** Administrative operations
#+begin_src scala
scala> client.addUser("aUser")
res0: Boolean = true

scala> // remove

scala> client.removeUser("aUser")
res1: Boolean = true

scala> // reset
scala> client.resetPassword("anotherUser")
res1: Boolean = true
#+end_src
**** build.sbt server
#+begin_src scala
name := "Actorbase"

version := "1.0"

scalaVersion := "2.11.8"

libraryDependencies ++= Seq(
  "com.typesafe.akka" %% "akka-actor" % "2.4.4",
  "com.typesafe.akka" %% "akka-testkit" % "2.4.4",
  "com.typesafe" % "config" % "1.2.1",
  "org.scalatest" % "scalatest_2.11" % "2.2.6" % "test",
  "io.spray" %% "spray-can" % "1.3.3",
  "io.spray" %% "spray-routing" % "1.3.3",
  "io.spray" %% "spray-json" % "1.3.2",
  "org.mindrot.t3hnar" % "scala-bcrypt_2.10" % "2.6")
)
#+end_src
**** build.sbt client
#+begin_src scala
name := "Actorbase-CLI"

version := "1.0"

scalaVersion := "2.11.8"

libraryDependencies ++= Seq(
  "com.typesafe" % "config" % "1.2.1",
  "org.scala-lang.modules" %% "scala-parser-combinators" % "1.0.2",
  "org.scala-lang" % "jline" % "2.11.0-M3",
  "org.scalatest" % "scalatest_2.11" % "2.2.6" % "test",
  "org.scalaj" %% "scalaj-http" % "2.3.0",
  "org.scala-lang.modules" %% "scala-pickling" % "0.10.1",
  "org.json4s" %% "json4s-native" % "3.3.0",
  "org.json4s" %% "json4s-jackson" % "3.3.0",
  "io.spray" %%  "spray-json" % "1.3.2")
#+end_src
**** build binaries
#+begin_src sh
// building with sbt
$ sbt assembly
$ ./target/scala-2.11/actorbase-1.0 --config=path/to/config.cfg
#+end_src
**** configuration sample
#+begin_src scala
actorbase {

  // address listening for connections
  addr = "127.0.0.1"
  // port open to connections
  port = 9999

  // storage configurations
  storage {
  // persistence storage path
  path = "path/to/storage"
  // type of persistence strategy
  // can be on-insert or on-timeout
  strategy = on-insert
  // on-timeout = 120 seconds  // interval of seconds between every save to disk
  on-insert = 20               // interval of insertions between every save to disk
  }

  // map size on storefinders and storekeepers
  map-size {
    storekeepr = 64
    storefinder = 256 // better set higher number on storefinder and low on storekeepers
  }

  // delay for multiple insertions
  // should change this value based on the type of data
  // and traffic that is expected to handle
  insert-delay = 1 // ms of delay, lower than 1 only if there is no high traffic expected
                   // higher for massive request incoming
}
#+end_src
**** cluster configuration sample
#+begin_src scala
akka {

  // setting cluster actor ref
  actor{
    provider = "akka.cluster.ClusterActorRefProvider"

    // default mailbox type, using control aware dispatching and
    // unbound mailbox, beware of memory consumption

    default-mailbox.mailbox-type = "akka.dispatch.UnboundedControlAwareMailbox"

    // deployment of main actors
    deployment./main {

      // routing type
      // can be all akka provided routing strategy e.g. Round robin pool,
      // or consistent-hashing pool or even a custom one
      router = round-robin-pool
      cluster.allow-local-routees = on

      // max number of routees per nodes (e.g. main actor per node)
      cluster.max-nr-of-instances-per-node = 10
      seed-nodes = ["akka.tcp://actorbase@127.0.0.1:2500", "akka.tcp://actorbase@127.0.0.1:2501"]
      cluster.enabled = on
    }
  }

}
#+end_src
